**READ THE ENTIRE REQUEST BEFORE GENERATING ANYTHING**

The following text is a request to fix ABAC rules. The text is separated into sections. To begin the text will name the section and the purpose of the section in this request.

	Prompt section:  This will be the main request we need accomplished through the query.

	README section: This section explains to you (the LLM engine) the essentials of a ABAC rule and how the attributes are made up. This section also includes the syntax we need. Use this section to help generate the rules we are requesting.


	ATTRIBUTE_DESCRIPTION section: is a sample policy for a healthcare organization. Analyze this file to better understand ABAC rule attributes for our organization. Also use this section to better understand the ATTRIBUTE_DATA section    

	
	
	ATTRIBUTE_DATA section: is the attribute data for our organization. This includes resources and users. Use these to create the ABAC rules being requested. 


	ACL section: This section contains our organizations entire ACL (access Control List), this is the list that needs to be converted into a set of ABAC rules that grant the exact same permissions. 
        this is also known as the ground truth ACL.


	PROMPT_RULES section: contains rules you need to follow. Rules that have to do with output results, the process, and other rules to help you (the LLM model) generate the exact results needed.

    CURRENT RULES SECTION: This section contains the current set of ABAC rules our organization has, and that needs IMPROVEMENT.

    ACL_COMPARISON: Has the information of over-permissions, under-permissions, and correct permissions that are generated by the current set of rules. 
    We compare those permissions to the ground truth ACL to generate the over-permissions, under-permissions, and correct permissions.

## Prompt

    We have a set of abac rules that are not giving the correct permissions. In other words we have many rules that are wrong
    The rules are found in the CURRENT RULES SECTION
    Please look at the ACL comparison data to look at the over-permissions and under-permissions, use this data to improve the CURRENT RULES
    HINT: YOU TEND TO GIVER OVER PERMISSIONS AND MAKE TOO MANY RULES (NOT ALWAYS THE CASE BUT MOST OFTEN IT IS)

## README
    # .abac Files Description

    This document outlines the format of .abac policy files. To ensure compatibility with the ABAC Lab application parser, please follow these guidelines when creating new policy files.

    For a detailed description of the policy language, please refer to our paper: TBD.

    Note that the two words "user" and "subject" are used interchangeably in this document.



    #

    An ABAC policy input file contains lines of the forms:

    ```
    userAttrib(uid, attribute1=value1, attribute2=value2, ...)

    resourceAttrib(rid, attribute1=value1, attribute2=value2, ...)
    ```

    The `userAttrib` and `resourceAttrib` lines define the users (subjects) and resources in the policy, respectively.
    - The first argument of a `userAttrib` is automatically assigned to an attribute named `uid`, which is the id of the user. 
    The first argument of a `resourceAttrib` is automatically assigned to an attribute named `rid`, which is the id of the resource.  
    - `value1`, `value2`, ... are atomic values or sets of atomic values.
    - An atomic value is a string that starts with a character other than a left curly brace.  
    - A set has the form `{element1 element2 ...}`. **Note that elements of a set are separated by spaces, not commas.**

    <br/>

    `userAttrib` and `resourceAttrib` statements must precede rule `statements` described below.

    <br/>

    ```
    rule(subCond; resCond; acts; cons)
    ```

    The `rule` lines define the rules of the policy.

    - `subCond` is a subject condition. It is a conjunction, with the conjuncts separated by commas. Each conjunct has the form 
    `attr [ {value1 value2 ...}`, where `attr` is a single-valued user attribute and `[` denotes the "in" operator (note that elements of a set are separated by spaces, not commas), or 
    `attr ] value`
    , where attr is a muli-valued attribute, value is an atomic value, and `]` denotes the "contains" operator.

    - `resCond` is a resource condition. The syntax is analogous to the syntax for subject condition.

    - `acts` is a set of actions.

    - `cons` is a constraint. It is a conjunction of atomic constraints, with the
    conjuncts separated by commas. An atomic constraint is a formula of one of the following forms:
    ```
    aum > arm 
    aus [ arm
    aum ] ars
    aus = ars
    ```
    , where `aus` is a single-valued user attribute, `aum` is a multi-valued user attribute, `ars` is a single-valued resource attribute, and `arm` is a multi-valued resource attribute. Note that `>` denotes the "supseteq" (⊇) operator.



    <br/>

    ```
    # Comments
    ```
    Lines starting with `#` are comments.

## PROMPT_RULES

        This section is the prompt-rules

        This is also divided into sections, the following is a description on the sections. Failure to adhere to any of these rules will result in a failed query on your (the LLM) part.

            INPUT section:

            OUTPUT section: The output section describes how to format your (the LLMs) response. Including syntax, restrictions, and content. 

            The ABAC RULES section, is section dedicated to helping you (the LLM) produce more consistent and correct abac rules. You (the LLM) are to follow these rules strictly.

            The VERIFICATION section: tasks for you (the LLM) to do in order to guarantee better results.

            The LLM IMPROVEMENT section, has other rules to help you (the LLM) produce better results.

        INPUT:

        OUTPUT:
            1. Only respond with the ABAC rules being requested.
            2. Each rule should follow strict ABAC syntax.
            3. Each rule should be in its own line.
            4. Respond only with plain text, no mark-up or other type of formatting. 
                a. unseen values are forbidden.
            5. Read the entire request before formulating response. 
            6. Use exactly: rule(<subCond> ; <resCond> ; <acts> ; <cons>)
            7. Every line must be a single rule and must match this exact shape: rule(<subCond> ; <resCond> ; <acts> ; <cons>).
                 The line MUST contain exactly three ; characters. 
                 The third field <acts> MUST be a set like {read write}.
                If a line has fewer/more than three semicolons, discard and regenerate before responding.
            8. Before emitting, verify for each line:
                line.startswith("rule(") and line.endswith(")")
                line.count(";") == 3
                The third field matches ^\{[^}]+\}$.”
         


        ABAC RULES:
            0. Here is a brief reminder of what ABAC rules should adhere to.
                The `rule` lines define the rules of the policy.

                        - `subCond` is a subject condition. It is a conjunction, with the conjuncts separated by commas. Each conjunct has the form 
                            `attr [ {value1 value2 ...}`, where `attr` is a single-valued user attribute and `[` denotes the "in" operator (note that 					 elements of a set are separated by spaces, not commas), or 
                        `attr ] value`, where attr is a muli-valued attribute, value is an atomic value, and `]` denotes the "contains" operator.

                        - `resCond` is a resource condition. The syntax is analogous to the syntax for subject condition.

                    - `acts` is a set of actions.

                        - `cons` is a constraint. It is a conjunction of atomic constraints, with the conjuncts separated by commas. An atomic constraint is a 					formula of one of the following forms:
            
                                aum > arm 
                                aus [ arm
                                aum ] ars
                                aus = ars
            
                                    , where `aus` is a single-valued user attribute, `aum` is a multi-valued user attribute, `ars` is a single-valued 						resource attribute, and `arm` is a multi-valued resource attribute. Note that `>` denotes the "supseteq" (⊇) 							operator.


            1. ABAC rules should not use resource ids like a uid or rid. AVOID USING at all costs. 
                a. Do not hard code any ids, the rules should be dynamic.
                b. Prefer constraints over hard-coded values to keep rules dynamic
            2. The generated rules must as concise as possible.
                a. Check all ABAC rules for redundancy, keep rules to strict minimum. 
            3. It is okay to exclude a section in an ABAC rule if the section is not needed. 
                a. You (the LLM) may leave out a subject condition if it makes the ABAC rule more concise.
                    1. For example: rule (; <resCond> ; <acts> ; <cons>)
            4. You (the LLM) must generate the fewest amount of rules that give the same exact permissions as the ACL that was provided.
            5.Over permitting or under permitting through the ABAC rules you (the LLM) generate will be considered a failed query on your (the LLMs) behalf.
                a. KEEP ACCESS TO A MINIMUM, DO NOT OVER GRANT OR UNDER GRANT PERMISSIONS
                b. DO NOT GENERALIZE ACCESS KEEP IT STRICT AND MAKE IT MATCH THE ACL WE ARE PROVIDING.
            6. You (the LLM) are allowed to combine rules for actions if they should grant the same access. 
                a. For example: rule (; subj ] {math}; {read, write, createNote}; class=class )
            7. ABAC rules do not need to dictate permit or deny as a section.
                a. INCORRECT = rule (; subj ] {math}; {read}; class=class, PERMIT )
            8. DO NOT ADD, REMOVE, OR EDIT ATTRIBUTES. ONLY GENERATE ABAC RULES.
            9. Do not use synonyms when describing actions, stick to the action on the ACL list ONLY.
            10. REMEMBER EACH RULE MUST BE IN PARANTHESIS AND LEAD WITH THE WORD "rule"
                example: rule()




        VERIFICATION:
            

        LLM IMPROVEMTNS: 
            1. Use a two-pass approach: 
                a. draft minimal candidate rules via grouping by action and shared attributes
                b. merge duplicates and validate equality against ACL before emitting.
            2. YOU (the LLM) cosntantly over permit, fix that issue.
            3. Always test internally: each rule must imply only the permissions found in the ACL. If a rule covers an extra user–resource–action triple not in the ACL, it is invalid.
            4. When uncertain between under-permitting and over-permitting, prefer under-permitting (fewer permissions). Do not attempt to “fill in” missing access by generalizing.
            5. Start from grouping by shared attribute conditions (e.g., same role, same team) and collapse actions into a single {…} set rather than generating multiple rules.
            6. Default to strictness: assume access is denied unless the ACL line explicitly allows it.
            7. Consolidate rules only after confirming they do not introduce extra permissions.
            8. Re-evaluate for redundancy: if two rules differ only in actions, merge them; if they differ in scope and one is a superset, drop the superset.
            9. each rule should have no more and no less that 3 semi colons ; 
                a.  less or more semi colons implies the rule is completely wrong.
                b. again the syntax of a rule should look like this in regards to sections and how they are seperated: rule(subCond; resCond; acts; cons)

            11. Do not over-permit. If a rule adds permissions not in the ACL, reject or tighten it.
                When uncertain, under-permit (fewer permissions) instead of over-permitting.
                Never use user ids or resource ids. Only use attributes and allowed constraints.
                Prefer constraints: ward=ward, teams ] treatingTeam, specialties > topics, uid=author, agentFor ] patient.
                Merge actions into one rule if subject and resource conditions are the same.
                Eliminate redundancy: drop supersets, keep only strict rules.
                Minimize rule count. Fewer generalized rules are always better if equivalence holds.
                Validate: expand rules to triples and compare to ACL. Must be exact match.
                If extra triples → tighten. If missing triples → adjust constraints without broadening.
                Never generalize roles alone (e.g., “all doctors”). Always tie access to attribute relations.





